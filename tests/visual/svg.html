<!DOCTYPE html>
<html>
<head>
  <title>SVG line tests | anime.js</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href="assets/css/styles.css" rel="stylesheet">
  <style>
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      position: absolute;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    .test {
      position: relative;
      width: 50%;
    }
    .test svg {
      position: relative;
      width: 100%;
      border: 1px dotted #F96F82;
    }
    #square {
      position: absolute;
      left: 0;
      top: 0;
      width: 30px;
      height: 30px;
      margin-left: -15px;
      margin-top: -15px;
      background-color: white;
    }
  </style>
</head>
<body>
  <div id="path-tests" class="test">
    <div id="square"></div>
    <svg preserveAspectRatio="xMidYMid slice" viewBox="0 0 600 400">
      <g fill="none" fill-rule="evenodd" stroke-width="2">
        <line id="line1" x1="51.5" x2="149.5" y1="51.5" y2="149.5" stroke="#F96F82" stroke-linecap="square"/>
        <line id="line2" x1="149.5" x2="51.5" y1="51.5" y2="149.5" stroke="#F96F82" stroke-linecap="square"/>
        <circle id="circle" cx="300" cy="100" r="50" stroke="#FED28B"/>
        <polygon id="polygon" stroke="#D1FA9E" points="500 130.381 464.772 149 471.5 109.563 443 81.634 482.386 75.881 500 40 517.614 75.881 557 81.634 528.5 109.563 535.228 149"/>
        <polyline id="polyline" stroke="#7BE6D6" points="63.053 345 43 283.815 95.5 246 148 283.815 127.947 345 63.5 345"/>
        <!-- <path id="path" stroke="#4E7EFC" d="M250 300c0-27.614 22.386-50 50-50s50 22.386 50 50v50h-50c-27.614 0-50-22.386-50-50z"/> -->
        <path id="path-without-d-attribute-1" stroke="#4E7EFC"/>
        <path id="path-without-d-attribute-2" stroke="#F96F82"/>
        <rect id="rect" width="100" height="100" x="451" y="251" stroke="#C987FE" rx="25"/>
      </g>
    </svg>
  </div>
  <div id="filters-tests" class="test">
    <svg width="128" height="128" viewBox="0 0 128 128">
      <filter id="displacementFilter">
        <feTurbulence type="turbulence" numOctaves="2" baseFrequency="0" result="turbulence"/>
        <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="1" xChannelSelector="R" yChannelSelector="G"/>
      </filter>
      <polygon style="filter: url(#displacementFilter)" stroke="#FED28B" fill="transparent"/>
    </svg>
  </div>
  <script type="module">
    import anime from '../../src/anime.js';
    import { test, expect } from './assets/js/tests.js';

    // Path tests

    const squareEl = document.querySelector('#square');
    const pathTestsEl = document.querySelector('#path-tests');

    const line1El = document.querySelector('#line1');
    const line2El = document.querySelector('#line2');
    const circleEl = document.querySelector('#circle');
    const polygonEl = document.querySelector('#polygon');
    const polylineEl = document.querySelector('#polyline');
    const rectEl = document.querySelector('#rect');
    const path1El = document.querySelector('#path-without-d-attribute-1');
    const path2El = document.querySelector('#path-without-d-attribute-2');

    const dashOffsetAnimation = anime({
      targets: ['line', 'circle', 'polygon', 'polyline', 'rect'],
      strokeDashoffset: [anime.setDashoffset, 0],
      easing: 'easeInOutSine',
      translateX: 100,
      // opacity: 0, NEEDS FIX ?
      duration: 500,
      complete: () => {
        test('stroke-dasharray on line 1 element', () => {
          return expect(line1.getAttribute('stroke-dasharray')).toBe('138.59292602539062');
        });
        test('stroke-dasharray on line 2 element', () => {
          return expect(line2.getAttribute('stroke-dasharray')).toBe('138.59292602539062');
        });
        test('stroke-dasharray on circle element', () => {
          return expect(circleEl.getAttribute('stroke-dasharray')).toBe('313.6517028808594');
        });
        test('stroke-dasharray on polygon element', () => {
          return expect(polygonEl.getAttribute('stroke-dasharray')).toBe('399.06207275390625');
        });
        test('stroke-dasharray on polyline element', () => {
          return expect(polylineEl.getAttribute('stroke-dasharray')).toBe('322.62371826171875');
        });
        test('stroke-dasharray on rect element', () => {
          return expect(rectEl.getAttribute('stroke-dasharray')).toBe('356.0674743652344');
        });
      }
    });
    test('stroke-dashoffset on line 1 element', () => {
      return expect(line1.getAttribute('stroke-dashoffset')).toBe('138.59292602539062');
    });
    test('stroke-dashoffset on line 2 element', () => {
      return expect(line2.getAttribute('stroke-dashoffset')).toBe('138.59292602539062');
    });
    test('stroke-dashoffset on circle element', () => {
      return expect(circleEl.getAttribute('stroke-dashoffset')).toBe('313.6517028808594');
    });
    test('stroke-dashoffset on polygon element', () => {
      return expect(polygonEl.getAttribute('stroke-dashoffset')).toBe('399.06207275390625');
    });
    test('stroke-dashoffset on polyline element', () => {
      return expect(polylineEl.getAttribute('stroke-dashoffset')).toBe('322.62371826171875');
    });
    test('stroke-dashoffset on rect element', () => {
      return expect(rectEl.getAttribute('stroke-dashoffset')).toBe('356.0674743652344');
    });

    test('Setting a non existing attribute', () => {
      return expect(path1El.getAttribute('d')).toBe(null);
    });
    anime.set(path1El, { d: 'M250 300c0-27.614 22.386-50 50-50s50 22.386 50 50v50h-50c-27.614 0-50-22.386-50-50z' });
    test('Setting a value on a non existing attribute', () => {
      return expect(path1El.getAttribute('d')).toBe('M250 300c0-27.614 22.386-50 50-50s50 22.386 50 50v50h-50c-27.614 0-50-22.386-50-50z');
    });

    test('Animating a non existing attribute', () => {
      return expect(path2El.getAttribute('d')).toBe(null);
    });
    const animateNonExistantAttribute = anime({
      targets: path2El,
      d: 'M250 300c0-27.614 22.386-50 50-50s50 22.386 50 50v50h-50c-27.614 0-50-22.386-50-50z',
      duration: 500,
      easing: 'easeInOutQuad',
      complete: () => {
        test('Animating a value on a non existing attribute', () => {
          return expect(path2El.getAttribute('d')).toBe('M250 300c0-27.614 22.386-50 50-50s50 22.386 50 50v50h-50c-27.614 0-50-22.386-50-50z');
        });
        const pathEl = anime.path(path2El);
        const dashOffsetAnimation = anime({
          targets: path2El,
          strokeDashoffset: [anime.setDashoffset, 0],
          easing: 'easeInOutSine',
          duration: 500,
          complete: () => {
            test('stroke-dasharray on path element', () => {
              return expect(path2El.getAttribute('stroke-dasharray')).toBe('335.6526184082031');
            });
          }
        });
        test('stroke-dashoffset on path element', () => {
          return expect(path2El.getAttribute('stroke-dashoffset')).toBe('335.6526184082031');
        });

        let pathsTestsRect = pathTestsEl.getBoundingClientRect();
        let squareRect = squareEl.getBoundingClientRect();
        test('Path animation not started', () => {
          return expect(squareRect.left - pathsTestsRect.left).toBe(-15);
        });
        const pathAnimation = anime({
          targets: squareEl,
          translateX: pathEl('x'),
          translateY: pathEl('y'),
          rotate: pathEl('angle'),
          easing: 'easeInOutSine',
          duration: 500,
          complete: function() {
            test('Path animation started', () => {
              pathsTestsRect = pathTestsEl.getBoundingClientRect();
              squareRect = squareEl.getBoundingClientRect();
              return expect(squareRect.left - pathsTestsRect.left).toBeSuperiorTo(30);
            });
          }
        });
      }
    });

    // Filters tests
    const feTurbulenceEl = document.querySelector('#filters-tests feTurbulence');
    const filterPolygonEl = document.querySelector('#filters-tests polygon');

    console.log(typeof feTurbulenceEl, feTurbulenceEl instanceof SVGElement);
    console.log(typeof filterPolygonEl, filterPolygonEl instanceof SVGElement);

    const filterAnimation = anime({
      targets: [filterPolygonEl, feTurbulenceEl, '#filters-tests feDisplacementMap'],
      points: '64 128 8.574 96 8.574 32 64 0 119.426 32 119.426 96',
      baseFrequency: .05,
      scale: 15,
      loop: true,
      direction: 'alternate',
      easing: 'easeInOutExpo'
    });

    test('Non stylistic SVG attribute should be declared in came case', () => {
      return expect(feTurbulenceEl.hasAttribute('baseFrequency')).toBe(true);
    });

    test('Non stylistic SVG attribute should be declared in came case', () => {
      return expect(feTurbulenceEl.hasAttribute('base-frequency')).toBe(false);
    });

  </script>
</body>
</html>
